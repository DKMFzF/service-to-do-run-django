{% load static %}

<div id="shader"></div>
<script id="vertex" type="x-shader/x-vertex">
  varying vec2 vUv;
	void main() { 
        gl_Position = vec4(position, 1.0);
        vUv = uv;
    }
</script>

<script id="fragment" type="x-shader/x-fragment">
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;
varying vec2 vUv;

void coswarp(inout vec3 trip, float warpsScale ){
    trip.xyz += warpsScale * .1 * cos(3. * trip.yzx + (u_time * .25));
    trip.xyz += warpsScale * .05 * cos(11. * trip.yzx + (u_time * .25));
    trip.xyz += warpsScale * .025 * cos(17. * trip.yzx + (u_time * .25));
}

void main() {
  vec2 uv = (gl_FragCoord.xy - u_resolution * .5) / u_resolution.yy + 0.5;
  float t = u_time * 0.1; // Уменьшили скорость изменения времени

  // Генерация бежевых цветов
  vec3 baseColor = vec3(0.9, 0.8, 0.7); // Базовый бежевый цвет (кремовый)
  vec3 variation = vec3(
      0.05 * cos(t + uv.x * 2.0), // Уменьшили амплитуду вариаций
      0.05 * cos(t + uv.y * 1.5 + 1.0), // Уменьшили амплитуду вариаций
      0.05 * cos(t + uv.x * 1.0 + 2.0)  // Уменьшили амплитуду вариаций
  );

  // Смешиваем базовый цвет с вариациями
  vec3 color = baseColor + variation;

  // Применяем coswarp для плавных изменений
  coswarp(color, 1.5); // Уменьшили интенсивность warping

  // Увеличиваем контрастность
  color = mix(color, vec3(0.8), 0.3); // Уменьшили смешивание для большей четкости

  gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
let camera, scene, renderer, clock;
let uniforms;

function init() {
    const container = document.getElementById("shader");

    clock = new THREE.Clock();
    camera = new THREE.Camera();
    camera.position.z = 1;

    scene = new THREE.Scene();

    const geometry = new THREE.PlaneBufferGeometry(2, 2);

    uniforms = {
        u_time: { type: "f", value: 1.0 },
        u_resolution: { type: "v2", value: new THREE.Vector2() },
    };

    const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: document.getElementById("vertex").textContent,
        fragmentShader: document.getElementById("fragment").textContent
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);

    container.appendChild(renderer.domElement);

    onWindowResize();
    window.addEventListener("resize", onWindowResize);
}

function onWindowResize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.u_resolution.value.x = renderer.domElement.width;
    uniforms.u_resolution.value.y = renderer.domElement.height;
}

function render() {
    uniforms.u_time.value = clock.getElapsedTime();
    renderer.render(scene, camera);
}

function animate() {
    render();
    requestAnimationFrame(animate);
}

init();
animate();
</script>
